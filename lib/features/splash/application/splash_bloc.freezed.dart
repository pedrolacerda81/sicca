// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'splash_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SplashEventTearOff {
  const _$SplashEventTearOff();

  _CheckUserStatus checkUserStatus() {
    return const _CheckUserStatus();
  }
}

/// @nodoc
const $SplashEvent = _$SplashEventTearOff();

/// @nodoc
mixin _$SplashEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkUserStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? checkUserStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkUserStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CheckUserStatus value) checkUserStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CheckUserStatus value)? checkUserStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CheckUserStatus value)? checkUserStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashEventCopyWith<$Res> {
  factory $SplashEventCopyWith(
          SplashEvent value, $Res Function(SplashEvent) then) =
      _$SplashEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashEventCopyWithImpl<$Res> implements $SplashEventCopyWith<$Res> {
  _$SplashEventCopyWithImpl(this._value, this._then);

  final SplashEvent _value;
  // ignore: unused_field
  final $Res Function(SplashEvent) _then;
}

/// @nodoc
abstract class _$CheckUserStatusCopyWith<$Res> {
  factory _$CheckUserStatusCopyWith(
          _CheckUserStatus value, $Res Function(_CheckUserStatus) then) =
      __$CheckUserStatusCopyWithImpl<$Res>;
}

/// @nodoc
class __$CheckUserStatusCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$CheckUserStatusCopyWith<$Res> {
  __$CheckUserStatusCopyWithImpl(
      _CheckUserStatus _value, $Res Function(_CheckUserStatus) _then)
      : super(_value, (v) => _then(v as _CheckUserStatus));

  @override
  _CheckUserStatus get _value => super._value as _CheckUserStatus;
}

/// @nodoc

class _$_CheckUserStatus implements _CheckUserStatus {
  const _$_CheckUserStatus();

  @override
  String toString() {
    return 'SplashEvent.checkUserStatus()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _CheckUserStatus);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkUserStatus,
  }) {
    return checkUserStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? checkUserStatus,
  }) {
    return checkUserStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkUserStatus,
    required TResult orElse(),
  }) {
    if (checkUserStatus != null) {
      return checkUserStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CheckUserStatus value) checkUserStatus,
  }) {
    return checkUserStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CheckUserStatus value)? checkUserStatus,
  }) {
    return checkUserStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CheckUserStatus value)? checkUserStatus,
    required TResult orElse(),
  }) {
    if (checkUserStatus != null) {
      return checkUserStatus(this);
    }
    return orElse();
  }
}

abstract class _CheckUserStatus implements SplashEvent {
  const factory _CheckUserStatus() = _$_CheckUserStatus;
}

/// @nodoc
class _$SplashStateTearOff {
  const _$SplashStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _UserUnauthenticated userUnauthenticated() {
    return const _UserUnauthenticated();
  }

  _UserAuthenticated userAuthenticated() {
    return const _UserAuthenticated();
  }
}

/// @nodoc
const $SplashState = _$SplashStateTearOff();

/// @nodoc
mixin _$SplashState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() userUnauthenticated,
    required TResult Function() userAuthenticated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_UserUnauthenticated value) userUnauthenticated,
    required TResult Function(_UserAuthenticated value) userAuthenticated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashStateCopyWith<$Res> {
  factory $SplashStateCopyWith(
          SplashState value, $Res Function(SplashState) then) =
      _$SplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashStateCopyWithImpl<$Res> implements $SplashStateCopyWith<$Res> {
  _$SplashStateCopyWithImpl(this._value, this._then);

  final SplashState _value;
  // ignore: unused_field
  final $Res Function(SplashState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$SplashStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'SplashState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() userUnauthenticated,
    required TResult Function() userAuthenticated,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_UserUnauthenticated value) userUnauthenticated,
    required TResult Function(_UserAuthenticated value) userAuthenticated,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SplashState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$UserUnauthenticatedCopyWith<$Res> {
  factory _$UserUnauthenticatedCopyWith(_UserUnauthenticated value,
          $Res Function(_UserUnauthenticated) then) =
      __$UserUnauthenticatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserUnauthenticatedCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements _$UserUnauthenticatedCopyWith<$Res> {
  __$UserUnauthenticatedCopyWithImpl(
      _UserUnauthenticated _value, $Res Function(_UserUnauthenticated) _then)
      : super(_value, (v) => _then(v as _UserUnauthenticated));

  @override
  _UserUnauthenticated get _value => super._value as _UserUnauthenticated;
}

/// @nodoc

class _$_UserUnauthenticated implements _UserUnauthenticated {
  const _$_UserUnauthenticated();

  @override
  String toString() {
    return 'SplashState.userUnauthenticated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserUnauthenticated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() userUnauthenticated,
    required TResult Function() userAuthenticated,
  }) {
    return userUnauthenticated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
  }) {
    return userUnauthenticated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
    required TResult orElse(),
  }) {
    if (userUnauthenticated != null) {
      return userUnauthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_UserUnauthenticated value) userUnauthenticated,
    required TResult Function(_UserAuthenticated value) userAuthenticated,
  }) {
    return userUnauthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
  }) {
    return userUnauthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
    required TResult orElse(),
  }) {
    if (userUnauthenticated != null) {
      return userUnauthenticated(this);
    }
    return orElse();
  }
}

abstract class _UserUnauthenticated implements SplashState {
  const factory _UserUnauthenticated() = _$_UserUnauthenticated;
}

/// @nodoc
abstract class _$UserAuthenticatedCopyWith<$Res> {
  factory _$UserAuthenticatedCopyWith(
          _UserAuthenticated value, $Res Function(_UserAuthenticated) then) =
      __$UserAuthenticatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserAuthenticatedCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements _$UserAuthenticatedCopyWith<$Res> {
  __$UserAuthenticatedCopyWithImpl(
      _UserAuthenticated _value, $Res Function(_UserAuthenticated) _then)
      : super(_value, (v) => _then(v as _UserAuthenticated));

  @override
  _UserAuthenticated get _value => super._value as _UserAuthenticated;
}

/// @nodoc

class _$_UserAuthenticated implements _UserAuthenticated {
  const _$_UserAuthenticated();

  @override
  String toString() {
    return 'SplashState.userAuthenticated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserAuthenticated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() userUnauthenticated,
    required TResult Function() userAuthenticated,
  }) {
    return userAuthenticated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
  }) {
    return userAuthenticated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? userUnauthenticated,
    TResult Function()? userAuthenticated,
    required TResult orElse(),
  }) {
    if (userAuthenticated != null) {
      return userAuthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_UserUnauthenticated value) userUnauthenticated,
    required TResult Function(_UserAuthenticated value) userAuthenticated,
  }) {
    return userAuthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
  }) {
    return userAuthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_UserUnauthenticated value)? userUnauthenticated,
    TResult Function(_UserAuthenticated value)? userAuthenticated,
    required TResult orElse(),
  }) {
    if (userAuthenticated != null) {
      return userAuthenticated(this);
    }
    return orElse();
  }
}

abstract class _UserAuthenticated implements SplashState {
  const factory _UserAuthenticated() = _$_UserAuthenticated;
}
